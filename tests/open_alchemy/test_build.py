"""Tests for the package builder."""

import sys

import pytest

from open_alchemy import build
from open_alchemy import exceptions


@pytest.mark.parametrize(
    "spec",
    [
        pytest.param(True, id="base invalid"),
        pytest.param({"components": {"schemas": {}}}, id="no schemas"),
        pytest.param(
            {
                "components": {
                    "schemas": {
                        "Schema1": {
                            "x-tablename": "schema_1",
                        }
                    }
                }
            },
            id="schema invalid",
        ),
    ],
)
@pytest.mark.build
def test_get_schemas_invalid(spec):
    """
    GIVEN invalid spec
    WHEN get_schemas is called
    THEN MalformedSchemaError is raised.
    """
    with pytest.raises(exceptions.MalformedSchemaError):
        build.get_schemas(spec=spec)


@pytest.mark.build
def test_get_schemas_valid():
    """
    GIVEN invalid spec
    WHEN get_schemas is called
    THEN MalformedSchemaError is raised.
    """
    spec = {
        "components": {
            "schemas": {
                "Schema1": {
                    "type": "object",
                    "x-tablename": "schema_1",
                    "properties": {"id": {"type": "integer"}},
                }
            }
        }
    }

    returned_schemas = build.get_schemas(spec=spec)

    assert returned_schemas == {
        "Schema1": {
            "type": "object",
            "x-tablename": "schema_1",
            "properties": {"id": {"type": "integer"}},
        }
    }


@pytest.mark.build
def test_generate_spec():
    """
    GIVEN schemas
    WHEN generate_spec is called with the schemas
    THEN the spec.json file contents with the schemas are returned.
    """
    schemas = {
        "Schema1": {
            "type": "object",
            "x-tablename": "schema_1",
            "properties": {"id": {"type": "integer"}},
        }
    }

    returned_contents = build.generate_spec(schemas=schemas)

    expected_contents = (
        '{"components":{"schemas":{"Schema1":'
        '{"type":"object","x-tablename":"schema_1",'
        '"properties":{"id":{"type":"integer"}}}}}}'
    )

    assert returned_contents == expected_contents


@pytest.mark.build
def test_generate_setup():
    """
    GIVEN name and version
    WHEN generate_setup is called with the name and version
    THEN the setup.py file contents with the name and version are returned.
    """
    name = "name 1"
    version = "version 1"

    returned_contents = build.generate_setup(name=name, version=version)

    expected_contents = """import setuptools

setuptools.setup(
    name="name 1",
    version="version 1",
    packages=setuptools.find_packages(),
    python_requires=">=3.6",
    install_requires=[
        "OpenAlchemy",
    ],
    include_package_data=True,
)
"""

    assert returned_contents == expected_contents


@pytest.mark.build
def test_generate_init_open_alchemy():
    """
    GIVEN name and version
    WHEN generate_init_open_alchemy is called with the name and version
    THEN the __init__.py file contents with the name and version are returned.
    """
    returned_contents = build.generate_init_open_alchemy()

    expected_contents = """import pathlib

from open_alchemy import init_json

parent_path = pathlib.Path(__file__).parent.absolute()
init_json(parent_path / "spec.json")"""

    assert returned_contents == expected_contents


_DOCSTRING = '"""Autogenerated SQLAlchemy models based on OpenAlchemy models."""'
_EXPECTED_TD_BASE = "typing.TypedDict"
if sys.version_info[1] < 8:
    _EXPECTED_TD_BASE = "typing_extensions.TypedDict"
_EXPECTED_MODEL_BASE = "typing.Protocol"
if sys.version_info[1] < 8:
    _EXPECTED_MODEL_BASE = "typing_extensions.Protocol"
_ADDITIONAL_IMPORT = ""
if sys.version_info[1] < 8:
    _ADDITIONAL_IMPORT = """
import typing_extensions"""


GENERATE_INIT_MODELS_FILE_TESTS = [
    # pylint: disable=line-too-long
    pytest.param(
        {
            "Schema1": {
                "type": "object",
                "x-tablename": "schema_1",
                "properties": {"id": {"type": "integer"}},
            }
        },
        f'''{_DOCSTRING}
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class Schema1Dict({_EXPECTED_TD_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]


class TSchema1({_EXPECTED_MODEL_BASE}):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Schema1.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[typing.Optional[int]]'

    def __init__(self, id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Schema1.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None) -> "TSchema1":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Schema1.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TSchema1":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> Schema1Dict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Schema1: typing.Type[TSchema1] = models.Schema1  # type: ignore
''',
        id="single",
    ),
    pytest.param(
        {
            "Schema1": {
                "allOf": [
                    {
                        "type": "object",
                        "x-tablename": "schema_1",
                        "properties": {"id": {"type": "integer"}},
                        "x-inherits": True,
                    },
                    {"$ref": "#/components/schemas/ParentSchema"},
                ]
            },
            "ParentSchema": {
                "type": "object",
                "x-tablename": "parent_schema",
                "properties": {"parent_id": {"type": "integer"}},
            },
        },
        f'''{_DOCSTRING}
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class Schema1Dict({_EXPECTED_TD_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]
    parent_id: typing.Optional[int]


class TSchema1({_EXPECTED_MODEL_BASE}):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Schema1.
        parent_id: The parent_id of the Schema1.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[typing.Optional[int]]'
    parent_id: 'sqlalchemy.Column[typing.Optional[int]]'

    def __init__(self, id: typing.Optional[int] = None, parent_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Schema1.
            parent_id: The parent_id of the Schema1.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, parent_id: typing.Optional[int] = None) -> "TSchema1":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Schema1.
            parent_id: The parent_id of the Schema1.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TSchema1":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> Schema1Dict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Schema1: typing.Type[TSchema1] = models.Schema1  # type: ignore


class ParentSchemaDict({_EXPECTED_TD_BASE}, total=False):
    """TypedDict for properties that are not required."""

    parent_id: typing.Optional[int]


class TParentSchema({_EXPECTED_MODEL_BASE}):
    """
    SQLAlchemy model protocol.

    Attrs:
        parent_id: The parent_id of the ParentSchema.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    parent_id: 'sqlalchemy.Column[typing.Optional[int]]'

    def __init__(self, parent_id: typing.Optional[int] = None) -> None:
        """
        Construct.

        Args:
            parent_id: The parent_id of the ParentSchema.

        """
        ...

    @classmethod
    def from_dict(cls, parent_id: typing.Optional[int] = None) -> "TParentSchema":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            parent_id: The parent_id of the ParentSchema.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TParentSchema":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> ParentSchemaDict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


ParentSchema: typing.Type[TParentSchema] = models.ParentSchema  # type: ignore
''',
        id="inherits",
    ),
    pytest.param(
        {
            "Schema1": {
                "type": "object",
                "x-tablename": "schema_1",
                "properties": {
                    "id": {"type": "integer"},
                    "schema_2": {
                        "allOf": [
                            {"$ref": "#/components/schemas/Schema2"},
                            {"x-backref": "schema_1"},
                        ]
                    },
                },
            },
            "Schema2": {
                "type": "object",
                "x-tablename": "schema_2",
                "properties": {"id": {"type": "integer"}},
            },
        },
        f'''{_DOCSTRING}
# pylint: disable=no-member,super-init-not-called,unused-argument

import typing

import sqlalchemy{_ADDITIONAL_IMPORT}
from sqlalchemy import orm

from open_alchemy import models

Base = models.Base  # type: ignore


class Schema1Dict({_EXPECTED_TD_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]
    schema_2: typing.Optional["Schema2Dict"]


class TSchema1({_EXPECTED_MODEL_BASE}):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Schema1.
        schema_2: The schema_2 of the Schema1.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[typing.Optional[int]]'
    schema_2: 'sqlalchemy.Column[typing.Optional["TSchema2"]]'

    def __init__(self, id: typing.Optional[int] = None, schema_2: typing.Optional["TSchema2"] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Schema1.
            schema_2: The schema_2 of the Schema1.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None, schema_2: typing.Optional["Schema2Dict"] = None) -> "TSchema1":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Schema1.
            schema_2: The schema_2 of the Schema1.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TSchema1":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> Schema1Dict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Schema1: typing.Type[TSchema1] = models.Schema1  # type: ignore


class Schema2Dict({_EXPECTED_TD_BASE}, total=False):
    """TypedDict for properties that are not required."""

    id: typing.Optional[int]


class TSchema2({_EXPECTED_MODEL_BASE}):
    """
    SQLAlchemy model protocol.

    Attrs:
        id: The id of the Schema2.
        schema_1: The schema_1 of the Schema2.

    """

    # SQLAlchemy properties
    __table__: sqlalchemy.Table
    __tablename__: str
    query: orm.Query

    # Model properties
    id: 'sqlalchemy.Column[typing.Optional[int]]'
    schema_1: 'sqlalchemy.Column[typing.Sequence["TSchema1"]]'

    def __init__(self, id: typing.Optional[int] = None, schema_1: typing.Optional[typing.Sequence["TSchema1"]] = None) -> None:
        """
        Construct.

        Args:
            id: The id of the Schema2.
            schema_1: The schema_1 of the Schema2.

        """
        ...

    @classmethod
    def from_dict(cls, id: typing.Optional[int] = None) -> "TSchema2":
        """
        Construct from a dictionary (eg. a POST payload).

        Args:
            id: The id of the Schema2.
            schema_1: The schema_1 of the Schema2.

        Returns:
            Model instance based on the dictionary.

        """
        ...

    @classmethod
    def from_str(cls, value: str) -> "TSchema2":
        """
        Construct from a JSON string (eg. a POST payload).

        Returns:
            Model instance based on the JSON string.

        """
        ...

    def to_dict(self) -> Schema2Dict:
        """
        Convert to a dictionary (eg. to send back for a GET request).

        Returns:
            Dictionary based on the model instance.

        """
        ...

    def to_str(self) -> str:
        """
        Convert to a JSON string (eg. to send back for a GET request).

        Returns:
            JSON string based on the model instance.

        """
        ...


Schema2: typing.Type[TSchema2] = models.Schema2  # type: ignore
''',
        id="backref",
    ),
]


@pytest.mark.parametrize("schemas, expected_contents", GENERATE_INIT_MODELS_FILE_TESTS)
@pytest.mark.build
def test_generate_init_models_file(schemas, expected_contents):
    """
    GIVEN schemas and expected contents
    WHEN generate_init_models_file is called with the schemas
    THEN the expected __init__.py file contents are returned.
    """
    returned_contents = build.generate_init_models_file(schemas=schemas)

    assert returned_contents == expected_contents
